
/*
  @author Raoul Harel
  @license The MIT license (../LICENSE.txt)
  @copyright 2015 Raoul Harel
  @url rharel/node-avl-tree on GitHub
 */

(function() {
  var AVLTree, assert, should;

  should = require('should');

  assert = require('./helpers.test');

  AVLTree = require('../lib/avl');

  describe('unit', function() {
    describe('initialization', function() {
      describe('default', function() {
        var t;
        t = new AVLTree;
        assert.it_should_be_empty(t);
        return it('should have a simple comparator', function() {
          t._comparator(3, 2).should.be.above(0);
          t._comparator(2, 3).should.be.below(0);
          return t._comparator(3, 3).should.be.equal(0);
        });
      });
      return describe('user arguments', function() {
        var comparator, t;
        comparator = function(a, b) {
          return b - a;
        };
        t = new AVLTree(comparator);
        assert.it_should_be_empty(t);
        return it('should accept user comparator', function() {
          return t._comparator.should.be.equal(comparator);
        });
      });
    });
    describe('insertion', function() {
      describe('into an empty tree', function() {
        var a, t;
        t = new AVLTree;
        a = t.insert(0, '0');
        assert.it_should_match_key_and_value(a, 0, '0');
        assert.it_should_be_the_root(a, t);
        return assert.it_should_be_a_leaf(a);
      });
      it('should have a default value of null', function() {
        var a, t;
        t = new AVLTree;
        a = t.insert(0);
        return (a.value != null).should.be.equal(false);
      });
      it('should return null when value is already present', function() {
        var a, b, t;
        t = new AVLTree;
        a = t.insert(0);
        b = t.insert(0);
        return (b != null).should.be.equal(false);
      });
      describe('balanced', function() {
        describe('into left', function() {
          var a, b, t;
          t = new AVLTree;
          a = t.insert(2, '2');
          b = t.insert(1, '1');
          assert.it_should_match_key_and_value(a, 2, '2');
          assert.it_should_be_the_root(a, t);
          assert.it_should_have_children(a, b, null);
          assert.it_should_have_props(a, 2, 1);
          assert.it_should_match_key_and_value(b, 1, '1');
          return assert.it_should_be_a_leaf(b);
        });
        return describe('into right', function() {
          var a, b, t;
          t = new AVLTree;
          a = t.insert(1, '1');
          b = t.insert(2, '2');
          assert.it_should_match_key_and_value(a, 1, '1');
          assert.it_should_be_the_root(a, t);
          assert.it_should_have_children(a, null, b);
          assert.it_should_have_props(a, 2, -1);
          assert.it_should_match_key_and_value(b, 2, '2');
          return assert.it_should_be_a_leaf(b);
        });
      });
      describe('imbalanced', function() {
        var test_case;
        test_case = function(name, x, y, z) {
          return describe(name, function() {
            var L, R, a, b, c, i, ref, ref1, root, t, vx, vy, vz;
            t = new AVLTree;
            ref = (function() {
              var j, len, ref, results;
              ref = [x, y, z];
              results = [];
              for (j = 0, len = ref.length; j < len; j++) {
                i = ref[j];
                results.push('' + i);
              }
              return results;
            })(), vx = ref[0], vy = ref[1], vz = ref[2];
            a = t.insert(x, vx);
            b = t.insert(y, vy);
            c = t.insert(z, vz);
            assert.it_should_match_key_and_value(a, x, vx);
            assert.it_should_match_key_and_value(b, y, vy);
            assert.it_should_match_key_and_value(c, z, vz);
            ref1 = [a, b, c].sort(function(p, q) {
              return p.key - q.key;
            }), L = ref1[0], root = ref1[1], R = ref1[2];
            assert.it_should_be_the_root(root, t);
            assert.it_should_have_children(root, L, R);
            assert.it_should_have_props(root, 2, 0);
            assert.it_should_be_a_leaf(L);
            return assert.it_should_be_a_leaf(R);
          });
        };
        test_case('LL', 3, 2, 1);
        test_case('LR', 3, 1, 2);
        test_case('RR', 1, 2, 3);
        return test_case('RL', 1, 3, 2);
      });
      return describe('verify structure after inserting [1..7]', function() {
        var L, LL, LR, R, RL, RR, i, j, k, len, node, ref, result, results, root, t;
        t = new AVLTree;
        result = (function() {
          var j, results;
          results = [];
          for (i = j = 1; j <= 7; i = ++j) {
            results.push(t.insert(i, '' + i));
          }
          return results;
        })();
        LL = result[0], L = result[1], LR = result[2], root = result[3], RL = result[4], R = result[5], RR = result[6];
        for (i = j = 1; j <= 7; i = ++j) {
          assert.it_should_match_key_and_value(result[i - 1], i, '' + i);
        }
        assert.it_should_be_the_root(root, t);
        assert.it_should_have_children(root, L, R);
        assert.it_should_have_props(root, 3, 0);
        assert.it_should_have_children(L, LL, LR);
        assert.it_should_have_props(L, 2, 0);
        assert.it_should_have_children(R, RL, RR);
        assert.it_should_have_props(R, 2, 0);
        ref = [LL, LR, RL, RR];
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          node = ref[k];
          results.push(assert.it_should_be_a_leaf(node));
        }
        return results;
      });
    });
    describe('search', function() {
      describe('in an empty tree', function() {
        var r, t;
        t = new AVLTree;
        r = t.search(0);
        return it('should return null', function() {
          return (r != null).should.be.equal(false);
        });
      });
      describe('in a tree missing the target value', function() {
        var i, j, k, results, t;
        t = new AVLTree;
        for (i = j = 1; j <= 7; i = ++j) {
          t.insert(i, '' + i);
        }
        results = [];
        for (i = k = 1; k <= 7; i = k += 2) {
          results.push((function(i) {
            var l, len, q, ref, results1;
            ref = [i - 0.5, i + 0.5];
            results1 = [];
            for (l = 0, len = ref.length; l < len; l++) {
              q = ref[l];
              results1.push((function(q) {
                return describe("search(" + q + ")", function() {
                  var r;
                  r = t.search(q);
                  return assert.it_should_match_key_and_value(r, i, '' + i);
                });
              })(q));
            }
            return results1;
          })(i));
        }
        return results;
      });
      return describe('in a tree containing the target value', function() {
        var i, j, k, results, t;
        t = new AVLTree;
        for (i = j = 1; j <= 7; i = ++j) {
          t.insert(i, '' + i);
        }
        results = [];
        for (i = k = 1; k <= 7; i = ++k) {
          results.push((function(i) {
            return describe("search(" + i + ")", function() {
              var r;
              r = t.search(i);
              return assert.it_should_match_key_and_value(r, i, '' + i);
            });
          })(i));
        }
        return results;
      });
    });
    return describe('deletion', function() {
      describe('in an empty tree', function() {
        var r, t;
        t = new AVLTree;
        r = t.remove(0);
        return it('should return null', function() {
          return (r != null).should.be.equal(false);
        });
      });
      describe('from a tree missing the deleted value', function() {
        var a, r, t;
        t = new AVLTree;
        a = t.insert(1, '1');
        r = t.remove(0);
        return it('should return null', function() {
          return (r != null).should.be.equal(false);
        });
      });
      describe('from single node tree by key', function() {
        var r, t, x;
        t = new AVLTree;
        x = t.insert(1, '1');
        r = t.remove(1);
        it('should return deleted node\'s value', function() {
          return r.should.be.equal('1');
        });
        assert.it_should_be_invalid(x);
        return assert.it_should_be_empty(t);
      });
      describe('from single node tree by node', function() {
        var r, t, x;
        t = new AVLTree;
        x = t.insert(1, '1');
        r = x.remove();
        it('should return deleted node\'s value', function() {
          return r.should.be.equal('1');
        });
        assert.it_should_be_invalid(x);
        return assert.it_should_be_empty(t);
      });
      describe('from tree by invalid node', function() {
        var b, r, t, x;
        t = new AVLTree;
        x = t.insert(1, '1');
        b = t.insert(2, '2');
        x.remove();
        r = x.remove();
        it('should return null', function() {
          return (r != null).should.be.equal(false);
        });
        assert.it_should_be_invalid(x);
        assert.it_should_be_the_root(b, t);
        return assert.it_should_be_a_leaf(b);
      });
      describe('balanced', function() {
        describe('from tree.length == 2', function() {
          var test_case;
          test_case = function(name, x, y, delete_root) {
            return describe(name, function() {
              var a, b, d_key, d_node, d_value, r, root, t;
              t = new AVLTree;
              a = t.insert(x, '' + x);
              b = t.insert(y, '' + y);
              d_key = delete_root ? x : y;
              d_value = '' + d_key;
              d_node = delete_root ? a : b;
              r = t.remove(d_key);
              it('should return deleted node\'s value', function() {
                return r.should.be.equal(d_value);
              });
              root = delete_root ? b : a;
              assert.it_should_be_invalid(d_node);
              assert.it_should_be_the_root(root, t);
              return assert.it_should_be_a_leaf(root);
            });
          };
          test_case('from root --> L deleting L', 2, 1, false);
          test_case('from root --> L deleting root', 2, 1, true);
          test_case('from root --> R deleting R', 1, 2, false);
          return test_case('from root --> R deleting root', 1, 2, true);
        });
        return describe('from tree.length == 3 deleting root', function() {
          var a, b, r, t, x;
          t = new AVLTree;
          a = t.insert(1, '1');
          x = t.insert(2, '2');
          b = t.insert(3, '3');
          r = t.remove(2);
          it('should return deleted node\'s value', function() {
            return r.should.be.equal('2');
          });
          assert.it_should_be_invalid(x);
          assert.it_should_be_the_root(a, t);
          assert.it_should_have_children(a, null, b);
          return assert.it_should_be_a_leaf(b);
        });
      });
      return describe('imbalanced', function() {
        describe('LL', function() {
          var L, R, i, r, ref, root, t, x;
          t = new AVLTree;
          ref = (function() {
            var j, len, ref, results;
            ref = [4, 3, 2, 1];
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              i = ref[j];
              results.push(t.insert(i, '' + i));
            }
            return results;
          })(), x = ref[0], R = ref[1], root = ref[2], L = ref[3];
          r = t.remove(4);
          it('should return deleted node\'s value', function() {
            return r.should.be.equal('4');
          });
          assert.it_should_be_invalid(x);
          assert.it_should_be_the_root(root, t);
          assert.it_should_have_children(root, L, R);
          assert.it_should_have_props(root, 2, 0);
          assert.it_should_be_a_leaf(L);
          return assert.it_should_be_a_leaf(R);
        });
        describe('RR', function() {
          var L, R, i, r, ref, root, t, x;
          t = new AVLTree;
          ref = (function() {
            var j, len, ref, results;
            ref = [1, 2, 3, 4];
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              i = ref[j];
              results.push(t.insert(i, '' + i));
            }
            return results;
          })(), x = ref[0], L = ref[1], root = ref[2], R = ref[3];
          r = t.remove(1);
          it('should return deleted node\'s value', function() {
            return r.should.be.equal('1');
          });
          assert.it_should_be_invalid(x);
          assert.it_should_be_the_root(root, t);
          assert.it_should_have_children(root, L, R);
          assert.it_should_have_props(root, 2, 0);
          assert.it_should_be_a_leaf(L);
          return assert.it_should_be_a_leaf(R);
        });
        describe('RL', function() {
          var L, R, i, r, ref, root, t, x;
          t = new AVLTree;
          ref = (function() {
            var j, len, ref, results;
            ref = [1, 2, 4, 3];
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              i = ref[j];
              results.push(t.insert(i, '' + i));
            }
            return results;
          })(), x = ref[0], L = ref[1], R = ref[2], root = ref[3];
          r = t.remove(1);
          it('should return deleted node\'s value', function() {
            return r.should.be.equal('1');
          });
          assert.it_should_be_invalid(x);
          assert.it_should_be_the_root(root, t);
          assert.it_should_have_children(root, L, R);
          assert.it_should_have_props(root, 2, 0);
          assert.it_should_be_a_leaf(L);
          return assert.it_should_be_a_leaf(R);
        });
        return describe('LR', function() {
          var L, R, i, r, ref, root, t, x;
          t = new AVLTree;
          ref = (function() {
            var j, len, ref, results;
            ref = [4, 3, 1, 2];
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              i = ref[j];
              results.push(t.insert(i, '' + i));
            }
            return results;
          })(), x = ref[0], R = ref[1], L = ref[2], root = ref[3];
          r = t.remove(4);
          it('should return deleted node\'s value', function() {
            return r.should.be.equal('4');
          });
          assert.it_should_be_invalid(x);
          assert.it_should_be_the_root(root, t);
          assert.it_should_have_children(root, L, R);
          assert.it_should_have_props(root, 2, 0);
          assert.it_should_be_a_leaf(L);
          return assert.it_should_be_a_leaf(R);
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=avl_unit.test.js.map
